/*
 * Copyright (c) 2020-2024 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.commons.logging.logback

import ch.qos.logback.classic.Level
import ch.qos.logback.classic.pattern.ClassicConverter
import ch.qos.logback.classic.spi.ILoggingEvent
import com.fasterxml.jackson.core.type.TypeReference
import io.airbyte.commons.constants.AirbyteCatalogConstants.LOCAL_SECRETS_MASKS_PATH
import io.airbyte.commons.constants.AirbyteSecretConstants
import io.airbyte.commons.logging.LOG_SOURCE_MDC_KEY
import io.airbyte.commons.logging.LogSource
import io.airbyte.commons.yaml.Yamls
import java.nio.charset.Charset
import java.util.regex.Pattern

/**
 * Custom [ClassicConverter] used to intercept all log messages and mask any JSON
 * properties in the message that match the list of maskable properties.
 * <p>
 * The maskable properties file is generated by a Gradle task in the
 * {@code :oss:airbyte-config:specs} project. The file is named {@code specs_secrets_mask.yaml} and
 * is located in the {@code src/main/resources/seed} directory of the
 * {@code :oss:airbyte-config:init} project.
 */
class MaskedDataConverter(
  specMaskFile: String = LOCAL_SECRETS_MASKS_PATH,
) : ClassicConverter() {
  private val pattern: Pattern? = buildPattern(specMaskFile = specMaskFile)
  private val replacePattern = API_KEY_PATTERN.toPattern()

  override fun convert(event: ILoggingEvent): String = replace(message = applyMask(event = event))

  /**
   * Applies the mask to the message, if necessary.
   *
   * @param event The log event.
   * @return The possibly masked log message.
   */
  private fun applyMask(event: ILoggingEvent): String {
    val piiScrubbedMessage = removeKnownPii(event = event)
    return pattern?.matcher(piiScrubbedMessage)?.replaceAll(REPLACEMENT_PATTERN) ?: piiScrubbedMessage
  }

  /**
   * Builds the maskable property matching pattern.
   *
   * @param specMaskFile The spec mask file.
   * @return The regular expression pattern used to find maskable properties.
   */
  private fun buildPattern(specMaskFile: String): Pattern? =
    getMaskableProperties(specMaskFile).takeIf { it.isNotEmpty() }?.let {
      generatePattern(it).toPattern()
    }

  /**
   * Generates the property matching pattern string from the provided set of properties.
   *
   * @param properties The set of properties to match.
   * @return The generated regular expression pattern used to match the maskable properties.
   */
  private fun generatePattern(properties: Set<String>): String =
    buildString {
      append(CASE_INSENSITIVE_FLAG)
      append(PROPERTY_MATCHING_PATTERN_PREFIX)
      append(properties.joinToString("|"))
      append(PROPERTY_MATCHING_PATTERN_SUFFIX)
    }

  /**
   * Loads the maskable properties from the provided file.
   *
   * @param specMaskFile The spec mask file.
   * @return The set of maskable properties.
   */
  private fun getMaskableProperties(specMaskFile: String): Set<String> {
    return runCatching {
      val maskFileContents =
        javaClass.getResourceAsStream(specMaskFile)?.readBytes()?.toString(Charset.defaultCharset())
          ?: return setOf()

      val properties: Map<String, Set<String>> =
        Yamls.deserialize(maskFileContents, object : TypeReference<Map<String, Set<String>>>() {})

      properties.getOrDefault(PROPERTIES_KEY, setOf())
    }.getOrDefault(setOf())
  }

  /**
   * Code-based implementation of the `replace(message){r, t}` macro in Logback/Log4j configuration.
   *
   * @param message The message to apply replacement to.
   * @return The potentially modified message with any specific patterns replaced.
   */
  private fun replace(message: String): String = replacePattern.matcher(message).replaceAll(API_KEY_REPLACEMENT)
}

/**
 * Name of the field that contains an API key.
 */
private const val API_KEY_FIELD = "apikey"

/**
 * Regular expression to match api keys in strings.  Ported from previous Log4j2 configuration.
 */
private const val API_KEY_PATTERN = "$API_KEY_FIELD=[\\w\\-]*"

/**
 * Replacement pattern for matches using the [API_KEY_PATTERN] regular expression.
 */
private const val API_KEY_REPLACEMENT = "$API_KEY_FIELD=${AirbyteSecretConstants.SECRETS_MASK}"

/**
 * Regular expression pattern flag that enables case in-sensitive matching.
 */
private const val CASE_INSENSITIVE_FLAG: String = "(?i)"

/**
 * Capture group name for the portion of a log message that contains the log information.
 */
private const val LOG_INFORMATION_PREFIX_CAPTURE_GROUP_NAME = "logInformationPrefix"

/**
 * Capture group name for the actual log message portion of a message.
 */
private const val MESSAGE_SOURCE_PREFIX_CAPTURE_GROUP_NAME = "messagePrefix"

/**
 * Regular expression replacement pattern for applying the mask to PII log messages.
 */
private const val KNOWN_PII_LOG_MESSAGE_REPLACEMENT_PATTERN: String =
  "\${$LOG_INFORMATION_PREFIX_CAPTURE_GROUP_NAME}" +
    "\${$MESSAGE_SOURCE_PREFIX_CAPTURE_GROUP_NAME}${AirbyteSecretConstants.SECRETS_MASK}"

/**
 * List of connector message sub-patterns that may contain potential PII.
 */
private val DESTINATION_PII_MESSAGES =
  listOf(
    "Received\\s+invalid\\s+message:",
    "org\\.jooq\\.exception\\.DataAccessException: SQL.+values\\s+\\(",
  )

/**
 * Pattern to find destination messages that contain potential PII.
 */
private val DESTINATION_KNOWN_PII_PATTERN =
  buildString {
    // capture group for the log level and caller information
    append("^(?<$LOG_INFORMATION_PREFIX_CAPTURE_GROUP_NAME>${Level.ERROR}.+)")
    // named capturing group for the targeted messages that need to be scrubbed
    append("(?<$MESSAGE_SOURCE_PREFIX_CAPTURE_GROUP_NAME>")
    // the actual messages that need to be scrubbed
    append(DESTINATION_PII_MESSAGES.joinToString("|"))
    // capture group for the actual message to be scrubbed
    append(")(.+)\$")
  }.toPattern()

/**
 * Name of the key in the mask YAML file that contains the list of maskable properties.
 */
private const val PROPERTIES_KEY: String = "properties"

/**
 * Regular expression pattern prefix for applying the mask to property values.
 */
private const val PROPERTY_MATCHING_PATTERN_PREFIX: String = "\"("

/**
 * Regular expression pattern suffix for applying the mask to property values.
 */
private const val PROPERTY_MATCHING_PATTERN_SUFFIX: String = ")\"\\s*:\\s*(\"(?:[^\"\\\\]|\\\\.)*\"|\\[[^]\\[]*]|\\d+)"

/**
 * Regular expression pattern used to replace a key/value property with a masked value while
 * maintaining the property key/name.
 */
private const val REPLACEMENT_PATTERN: String = "\"\$1\":\"${AirbyteSecretConstants.SECRETS_MASK}\""

/**
 * Removes known PII from the log message for messages produced by destinations.
 *
 * @param event The log event
 * @return a redacted log line if from a destination, otherwise returns the formatted log message
 */
private fun removeKnownPii(event: ILoggingEvent): String {
  /*
   * Only apply the PII replacement to messages from the destination to avoid performance
   * hit in other scenarios.
   */
  return if (event.mdcPropertyMap.getOrDefault(LOG_SOURCE_MDC_KEY, LogSource.PLATFORM.displayName) == LogSource.DESTINATION.displayName) {
    DESTINATION_KNOWN_PII_PATTERN.matcher(event.formattedMessage).replaceAll(KNOWN_PII_LOG_MESSAGE_REPLACEMENT_PATTERN)
  } else {
    event.formattedMessage
  }
}
