micronaut:
  application:
    name: airbyte-workload-api-server
  caches:
    dataplane-name:
      expire-after-write: 10m
    dataplane-group:
      expire-after-write: 10m
  executors:
    health:
      type: fixed
      n-threads: ${HEALTH_TASK_EXECUTOR_THREADS:3}
    io:
      type: fixed
      n-threads: ${IO_TASK_EXECUTOR_THREADS:10} # Match the data source max pool size below
    workload:
      type: fixed
      n-threads: ${WORKLOAD_TASK_EXECUTOR_THREADS:50}
  metrics:
    enabled: ${MICROMETER_METRICS_ENABLED:false}
    binders:
      netty:
        bytebuf-allocators:
          enabled: false
        channels:
          enabled: false
        queues:
          enabled: false
      web:
        enabled: true
        server:
          percentiles: "0.95"
        client:
          percentiles: "0.95"
    export:
      otlp:
        enabled: ${MICROMETER_METRICS_OTLP_ENABLED:false}
        step: ${MICROMETER_METRICS_STEP:PT30S}
        url: ${OTEL_COLLECTOR_ENDPOINT:`http://localhost:4318/v1/metrics`}
      statsd:
        enabled: ${MICROMETER_METRICS_STATSD_ENABLED:false}
        flavor: ${MICROMETER_METRICS_STATSD_FLAVOR:datadog}
        step: ${MICROMETER_METRICS_STEP:PT30S}
        host: ${STATSD_HOST:localhost}
        port: ${STATSD_PORT:8125}
  security:
    authentication-provider-strategy: ALL
    enabled: ${API_AUTHORIZATION_ENABLED:false}
    token:
      enabled: ${API_AUTHORIZATION_ENABLED:false}
      jwt:
        enabled: ${API_AUTHORIZATION_ENABLED:false}
        signatures:
          secret:
            generator:
              secret: ${AB_JWT_SIGNATURE_SECRET:}
  server:
    port: 8007
    idle-timeout: ${HTTP_IDLE_TIMEOUT:5m}
    netty:
      access-logger:
        enabled: ${HTTP_ACCESS_LOG_ENABLED:false}
      aggregator:
        max-content-length: 52428800 # 50MB
    max-request-size: 10485760 # 10MB the micronaut default. If we want to bump, double check it works for nginx.

airbyte:
  dataplane-groups:
    default-dataplane-group-name: ${DEFAULT_DATAPLANE_GROUP_NAME:}
  license-key: ${AIRBYTE_LICENSE_KEY:empty}
  edition: ${AIRBYTE_EDITION:COMMUNITY}
  feature-flag:
    client: ${FEATURE_FLAG_CLIENT:CONFIGFILE}
    path: ${FEATURE_FLAG_PATH:/flags}
    api-key: ${LAUNCHDARKLY_KEY:}
    base-url: ${FEATURE_FLAG_BASEURL:}
  internal-api:
    base-path: ${INTERNAL_API_HOST}/api
    connect-timeout-seconds: ${AIRBYTE_API_CONNECT_TIMEOUT_SECONDS:30}
    read-timeout-seconds: ${AIRBYTE_API_READ_TIMEOUT_SECONDS:600}
    retries:
      delay-seconds: ${AIRBYTE_API_RETRY_DELAY_SECONDS:2}
      max: ${AIRBYTE_API_MAX_RETRIES:5}
    auth:
      type: INTERNAL_CLIENT_TOKEN
      signature-secret: ${AB_JWT_SIGNATURE_SECRET:}
  secret:
    persistence: "no_op"
  auth:
    identity-provider:
      type: simple
  workload-api:
    workload-redelivery-window: ${WORKLOAD_REDELIVERY_WINDOW:PT5M}

endpoints:
  all:
    port: 8085
  beans:
    enabled: true
    sensitive: false
  env:
    enabled: true
    sensitive: false
  health:
    enabled: true
    jdbc:
      enabled: false
    sensitive: false
  info:
    enabled: true
    sensitive: true
  loggers:
    enabled: true
    sensitive: false
  metrics:
    enabled: ${MICROMETER_METRICS_ENABLED:false}
    sensitive: false
  refresh:
    enabled: false
    sensitive: true
  routes:
    enabled: true
    sensitive: false
  threaddump:
    enabled: true
    sensitive: true

datasources:
  config:
    connection-test-query: SELECT 1
    connection-timeout: 30000
    maximum-pool-size: ${CONFIG_DB_MAX_POOL_SIZE:10}
    minimum-idle: 5 # Keep 5 connections ready to reduce creation spikes
    idle-timeout: 600000 # Close truly unused connections after 10 min
    keepalive-time: 300000 # Send keepalive every 5 min to prevent network timeout
    max-lifetime: 1800000 # Force refresh connections every 30 min to prevent staleness
    initialization-fail-timeout: -1 # Disable fail fast checking to avoid issues due to other pods not being started in time
    url: ${DATABASE_URL}
    driverClassName: org.postgresql.Driver
    username: ${DATABASE_USER}
    password: ${DATABASE_PASSWORD:}
    leak-detection-threshold: 40000 # This should be slightly higher than the connection-timeout setting but not too high to avoid false positives and negatives.

logger:
  levels:
    com.zaxxer.hikari: ERROR
    com.zaxxer.hikari.pool: ERROR
    io.grpc: INFO
    io.fabric8.kubernetes.client: INFO
    io.netty: INFO
#   Uncomment to help resolve issues with conditional beans
#    io.micronaut.context.condition: DEBUG
#   Uncomment to help resolve issues with security beans
#    io.micronaut.security: DEBUG
#   Uncomment to help resolve issues with micronaut data
#    io.micronaut.data.query: TRACE
#    com.zaxxer.hikari.HikariConfig: DEBUG
#    com.zaxxer.hikari: TRACE

jackson:
  mapper:
    ACCEPT_CASE_INSENSITIVE_ENUMS: true
  serialization-inclusion: always
