/* eslint-disable */
/**
 * Generated by orval üç∫
 * Do not edit manually. Run "pnpm run generate-client" instead.
 * Airbyte Cloud Configuration API
 * Airbyte Cloud Configuration API
[https://airbyte.io](https://airbyte.io).

This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.

Here are some conventions that this API follows:
* All endpoints are http POST methods.
* All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params.
* The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`.
* For all `update` methods, the whole object must be passed in, even the fields that did not change.

Change Management:
* The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create`
* Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests.
* All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):
  * Adding fields to request or response bodies.
  * Adding new HTTP endpoints.

 * OpenAPI spec version: 1.0.0
 */
/**
 * Exception occurred; see message for details.
 */
export type ExceptionResponseResponse = KnownExceptionInfo;

/**
 * Object with given id was not found.
 */
export type NotFoundResponseResponse = NotFoundKnownExceptionInfo;

export interface InvalidInputExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  validationErrors: InvalidInputProperty[];
}

/**
 * Input failed validation
 */
export type InvalidInputResponseResponse = InvalidInputExceptionInfo;

export interface KnownExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

export interface NotFoundKnownExceptionInfo {
  id?: string;
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

export interface InvalidInputProperty {
  propertyPath: string;
  invalidValue?: string;
  message?: string;
}

/**
 * A dbt Cloud job
 */
export interface DbtCloudJobInfo {
  /** The account id associated with the job */
  accountId: number;
  /** The the specific job id returned by the dbt Cloud API */
  jobId: number;
  /** The human-readable name of the job returned by the dbt Cloud API */
  jobName: string;
}

/**
 * The available dbt Cloud jobs for the requested workspace config
 */
export interface WorkspaceGetDbtJobsResponse {
  availableDbtJobs: DbtCloudJobInfo[];
}

/**
 * Get the available dbt Cloud jobs associated with the given workspace config.
 */
export interface WorkspaceGetDbtJobsRequest {
  workspaceId: WorkspaceId;
  /** The config id associated with the dbt Cloud config, references the webhookConfigId in the core API. */
  dbtConfigId: string;
}

export type PermissionCheckReadStatus = (typeof PermissionCheckReadStatus)[keyof typeof PermissionCheckReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermissionCheckReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export interface PermissionCheckRead {
  status: PermissionCheckReadStatus;
  message?: string;
}

/**
 * Describes what actions/endpoints the permission entitles to
 */
export type PermissionType = (typeof PermissionType)[keyof typeof PermissionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermissionType = {
  instance_admin: "instance_admin",
  workspace_owner: "workspace_owner",
} as const;

export interface PermissionCheckRequest {
  permissionType: PermissionType;
  userId: UserId;
  workspaceId?: WorkspaceId;
}

export interface PermissionUpdate {
  permissionId: string;
  permissionType?: PermissionType;
  userId?: UserId;
  workspaceId?: WorkspaceId;
}

export interface PermissionRead {
  permissionId: string;
  permissionType?: PermissionType;
  userId: UserId;
  workspaceId?: WorkspaceId;
}

export interface PermissionReadList {
  permissions: PermissionRead[];
}

export interface PermissionCreate {
  permissionType?: PermissionType;
  userId: UserId;
  workspaceId?: WorkspaceId;
}

export interface PermissionIdRequestBody {
  permissionId: string;
}

export interface ConsumptionRead {
  timeframe: string;
  /** Billed costs consumed. */
  billedCost: number;
  /** Free usages consumed. */
  freeUsage: number;
  connection: ConnectorConsumptionRead;
}

/**
 * If time window is not provided, we will calculate consumptions in the last 30 days aggregated on a daily basis.
 */
export type CloudWorkspaceUsageRequestBodyAggregation =
  (typeof CloudWorkspaceUsageRequestBodyAggregation)[keyof typeof CloudWorkspaceUsageRequestBodyAggregation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CloudWorkspaceUsageRequestBodyAggregation = {
  daily: "daily",
  weekly: "weekly",
  monthly: "monthly",
} as const;

export interface CloudWorkspaceUsageRequestBody {
  workspaceId: WorkspaceId;
  /** Start time window to calculate workspace consumptions */
  start?: string;
  /** End time window to calculate workspace consumptions */
  end?: string;
  /** If time window is not provided, we will calculate consumptions in the last 30 days aggregated on a daily basis. */
  aggregation?: CloudWorkspaceUsageRequestBodyAggregation;
}

export interface DailyConsumptionRead {
  date: string;
  /** Number of credits consumed rounded to two decimal places. */
  creditsConsumed: number;
}

export type ConnectorConsumptionReadStatus =
  (typeof ConnectorConsumptionReadStatus)[keyof typeof ConnectorConsumptionReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectorConsumptionReadStatus = {
  active: "active",
  inactive: "inactive",
  deprecated: "deprecated",
} as const;

export interface ConnectorConsumptionRead {
  connectionId: string;
  connectionName: string;
  status: ConnectorConsumptionReadStatus;
  /** Number of credits consumed rounded to two decimal places. */
  creditsConsumed?: number;
  sourceId: string;
  sourceDefinitionId: string;
  /** Name of the type of source */
  sourceDefinitionName: string;
  /** Name of this particular source as used in a single sync connection */
  sourceConnectionName: string;
  /** Icon of the source actor. */
  sourceIcon: string;
  destinationId: string;
  destinationDefinitionId: string;
  /** Name of the type of destination */
  destinationDefinitionName: string;
  /** Name of this particular destination as used in a single sync connection */
  destinationConnectionName: string;
  /** Icon of the destination actor. */
  destinationIcon: string;
  connectionScheduleType?: string;
  connectionScheduleTimeUnit?: string;
  connectionScheduleUnits?: number;
}

export interface CloudWorkspaceUsageRead {
  workspaceId: WorkspaceId;
  creditConsumptionByConnector: ConnectorConsumptionRead[];
  creditConsumptionByDay: DailyConsumptionRead[];
  consumptionPerConnectionPerTimeframe: ConsumptionRead[];
}

export interface CloudWorkspaceUpdate {
  name?: string;
  workspaceId: WorkspaceId;
  creatorUserId?: UserId;
  /** If not set or false, the configuration is active. If true, then this configuration is permanently off. */
  tombstone?: boolean;
}

/**
 * Status of the workspace's credit balance, to determine if sync jobs can be launched for this workspace.
 */
export type CloudWorkspaceReadCreditStatus =
  (typeof CloudWorkspaceReadCreditStatus)[keyof typeof CloudWorkspaceReadCreditStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CloudWorkspaceReadCreditStatus = {
  positive: "positive",
  negative_within_grace_period: "negative_within_grace_period",
  negative_beyond_grace_period: "negative_beyond_grace_period",
  negative_max_threshold: "negative_max_threshold",
} as const;

export interface CloudWorkspaceRead {
  name?: string;
  workspaceId: WorkspaceId;
  creatorUserId?: UserId;
  /** If not set or false, the configuration is active. If true, then this configuration is permanently off. */
  tombstone?: boolean;
  remainingCredits?: number;
  /** Status of the workspace's credit balance, to determine if sync jobs can be launched for this workspace. */
  creditStatus?: CloudWorkspaceReadCreditStatus;
  /** The timestamp of the last time that credits were incremented for this workspace as a result of a credit purchase. Format is in unix epoch time milliseconds. */
  lastCreditPurchaseIncrementTimestamp?: number;
  /** The timestamp of when the workspace trial's expires. Format is in unix epoch time milliseconds. Unset if workspace is out of trial. */
  trialExpiryTimestamp?: number;
  userPaymentAccountId?: UserPaymentAccountId;
}

export interface CloudWorkspaceReadList {
  workspaces: CloudWorkspaceRead[];
}

export interface PermissionedCloudWorkspaceCreate {
  name: string;
  userId: UserId;
}

export interface CloudWorkspaceCreate {
  name?: string;
  workspaceId: WorkspaceId;
  creatorUserId: UserId;
}

/**
 * Metadata that Airbyte populates on the Checkout Session. At the moment, this only contains the Airbyte workspace ID
 */
export type StripeCheckoutSessionCompletedObjectMetadata = { [key: string]: string } | null;

/**
 * The data payload of the webhook event. Redundantly, the actual Checkout Session object is further nested inside the 'object' property of this 'data' field. Since this comes directly from Stripe, we do not have control over this structure
 */
export type StripeCheckoutSessionCompletedEventData = {
  object: StripeCheckoutSessionCompletedObject;
};

/**
 * The type of the webhook event. This spec only allows the following value, as this endpoint only processes Checkout Session Completed events
 */
export type StripeCheckoutSessionCompletedEventType =
  (typeof StripeCheckoutSessionCompletedEventType)[keyof typeof StripeCheckoutSessionCompletedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripeCheckoutSessionCompletedEventType = {
  checkoutsessioncompleted: "checkout.session.completed",
} as const;

/**
 * Webhook event coming from Stripe for the checkout.session.completed event
 */
export interface StripeCheckoutSessionCompletedEvent {
  /** ID of the Stripe webhook event */
  id: string;
  /** The creation time of the Stripe webhook event in unix time seconds */
  created?: number;
  /** The type of the webhook event. This spec only allows the following value, as this endpoint only processes Checkout Session Completed events */
  type: StripeCheckoutSessionCompletedEventType;
  /** The data payload of the webhook event. Redundantly, the actual Checkout Session object is further nested inside the 'object' property of this 'data' field. Since this comes directly from Stripe, we do not have control over this structure */
  data: StripeCheckoutSessionCompletedEventData;
}

/**
 * Output of creating a Stripe Checkout Session, containing the session URL
 */
export interface StripeCheckoutSessionRead {
  /** The URL of the Stripe Checkout Session created for this purchase, which the user should be redirected to */
  stripeUrl: string;
}

/**
 * Stripe's 'mode' param for the Stripe Checkout Session API. If unspecified, default to 'payment'
 */
export type StripeMode = (typeof StripeMode)[keyof typeof StripeMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripeMode = {
  payment: "payment",
  setup: "setup",
} as const;

/**
 * The actual Checkout Session object in the webhook event. This has been pared down to contain only the necessary event properties for this API to function
 */
export interface StripeCheckoutSessionCompletedObject {
  /** ID of the Checkout Session object in Stripe */
  id: string;
  /** The mode of the completed Checkout Session */
  mode: StripeMode;
  /** The ID of the customer for the Session. Airbyte refers to this as the 'Stripe Customer ID' */
  customer: string;
  /** The Stripe Invoice ID associated with the completed session, if one exists. */
  invoice?: string;
  /** The Stripe Payment Intent ID associated with the completed session, if one exists. */
  payment_intent?: string;
  /** Metadata that Airbyte populates on the Checkout Session. At the moment, this only contains the Airbyte workspace ID */
  metadata?: StripeCheckoutSessionCompletedObjectMetadata;
}

export interface WorkspaceFreeConnectorProgramInfoResponse {
  hasEligibleConnector: boolean;
  hasPaymentAccountSaved: boolean;
}

/**
 * List of workspace IDs
 */
export interface WorkspaceIdList {
  workspaceIds: WorkspaceId[];
}

/**
 * Input to filter workspaces with most recently running jobs within the given time window
 */
export interface TimeWindowRequestBody {
  /** Time window value (in hours), e.g. 48 */
  timeWindowInHours: number;
}

/**
 * Number of credits bought by the customer
 */
export type Credits = number;

/**
 * Workspace Id from OSS Airbyte instance
 */
export type WorkspaceId = string;

/**
 * Input for creating a Stripe Checkout Session for an Airbyte workspace
 */
export interface StripeCheckoutSessionCreate {
  workspaceId: WorkspaceId;
  /** The Airbyte URL that the user should be redirected to upon payment success */
  successUrl: string;
  /** The Airbyte URL that the user should be redirected to upon payment cancellation */
  cancelUrl: string;
  /** For payment mode only. Optional quantity of credits to use in the Stripe Checkout Session (can still be adjusted by the user). If unspecified, a default quantity will be set */
  quantity?: Credits;
  /** The mode that the Checkout Session should be created in. */
  stripeMode?: StripeMode;
}

export interface WorkspaceCreditsRequestBody {
  workspaceId: WorkspaceId;
  credits: Credits;
}

export interface WorkspaceIdRequestBody {
  workspaceId: WorkspaceId;
}

export interface WorkspaceRevokeUser {
  email: string;
  workspaceId: WorkspaceId;
}

export interface ResendUserInviteWithSignInLink {
  email: string;
  continueUrl?: string;
}

/**
 * Indicates from which page an invitation was initiated.
 */
export type WorkspaceUserInviteWithSignInLinkMetadataInvitedFrom =
  (typeof WorkspaceUserInviteWithSignInLinkMetadataInvitedFrom)[keyof typeof WorkspaceUserInviteWithSignInLinkMetadataInvitedFrom];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkspaceUserInviteWithSignInLinkMetadataInvitedFrom = {
  source: "source",
  destination: "destination",
  user_settings: "user_settings",
} as const;

/**
 * Metadata about the request that Airbyte uses for analytics and tracking purposes.
 */
export type WorkspaceUserInviteWithSignInLinkMetadata = {
  /** Indicates from which page an invitation was initiated. */
  invitedFrom?: WorkspaceUserInviteWithSignInLinkMetadataInvitedFrom;
};

export interface WorkspaceUserInviteWithSignInLink {
  email: string;
  workspaceId: WorkspaceId;
  continueUrl?: string;
  /** Metadata about the request that Airbyte uses for analytics and tracking purposes. */
  metadata?: WorkspaceUserInviteWithSignInLinkMetadata;
}

export interface WorkspaceUserInvite {
  email: string;
  workspaceId: WorkspaceId;
}

export interface WorkspaceUserReadList {
  users: WorkspaceUserRead[];
}

/**
 * Auth Provider
 */
export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthProvider = {
  google_identity_platform: "google_identity_platform",
} as const;

/**
 * user status
 */
export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatus = {
  invited: "invited",
  registered: "registered",
  disabled: "disabled",
} as const;

export interface WorkspaceUserRead {
  /** Caption name for the user */
  name?: string;
  userId: UserId;
  isDefaultWorkspace: boolean;
  status: UserStatus;
  email: string;
  permissionId: string;
  permissionType: PermissionType;
  workspaceId: WorkspaceId;
}

export interface UserUpdate {
  /** Caption name for the user */
  name?: string;
  userId: UserId;
  /** The userId from the Auth provider */
  authUserId?: string;
  authProvider?: AuthProvider;
  defaultWorkspaceId?: WorkspaceId;
  status?: UserStatus;
  companyName?: string;
  email?: string;
  news?: boolean;
}

export interface UserRead {
  /** Caption name for the user */
  name?: string;
  userId: UserId;
  /** The userId from the Auth provider */
  authUserId: string;
  authProvider: AuthProvider;
  defaultWorkspaceId: WorkspaceId;
  status?: UserStatus;
  companyName?: string;
  email: string;
  news?: boolean;
  intercomHash?: string;
}

export interface UserReadList {
  users: UserRead[];
}

/**
 * UserPaymentAccount ID from the Cloud database
 */
export type UserPaymentAccountId = string;

export interface UserCreate {
  /** Caption name for the user */
  name: string;
  /** The userId from the Auth provider */
  authUserId: string;
  authProvider: AuthProvider;
  status?: UserStatus;
  companyName?: string;
  email: string;
  news?: boolean;
}

export interface UserAuthIdRequestBody {
  authUserId: string;
  authProvider: AuthProvider;
}

export interface UserEmailRequestBody {
  email: string;
}

/**
 * Internal Airbyte Cloud User ID
 */
export type UserId = string;

export interface UserIdRequestBody {
  userId: UserId;
}

export interface HealthCheckRead {
  db: boolean;
}
