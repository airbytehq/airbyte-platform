/*
 * Copyright (c) 2020-2025 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config.helpers

import io.airbyte.commons.json.Jsons
import io.airbyte.config.JobTypeResourceLimit
import io.airbyte.config.ResourceRequirements
import io.airbyte.config.ScopedResourceRequirements
import io.github.oshai.kotlinlogging.KotlinLogging

private val logger = KotlinLogging.logger {}

/**
 * Manages resource requirements for different types of jobs. We follow a standard pattern of
 * priority for which requirements get used. See getResourceRequirements below.
 *
 * Auto-converted to Kotlin w/ some manual cleanup.
 */
object ResourceRequirementsUtils {
  /**
   * Given connection-level resource requirements, actor-level resource requirements, actor-definition-level
   * resource requirements, worker-default resource requirements, and a job type, returns the final resource
   * requirements generated by merging the provided requirements in hierarchy order.
   *
   * Connection-level resource requirements take precedence over actor-level resource requirements.
   * Actor-level resource requirements take precedence over actor definition-level resource requirements.
   * Actor definition-level resource requirements take precedence over worker default resource requirements.
   * Within the actor- and actor-definition level requirements, job-type-specific requirements take
   * precedence over default definition requirements.
   *
   * @param connectionResourceReqs - the resource requirements set on the connection
   * @param actorResourceReqs - the resource requirements set on the actor
   * @param actorDefinitionResourceReqs - the resource requirements set on the actor definition
   * @param workerDefaultResourceReqs - the default worker resource requirements set in the env
   * variables
   * @param jobType - type of job to extract resource requirements for from the actor definition reqs
   * @return resource requirements, if present, otherwise an empty ResourceRequirements object.
   */
  @JvmStatic
  fun getResourceRequirementsForJobType(
    connectionResourceReqs: ResourceRequirements?,
    actorResourceReqs: ScopedResourceRequirements?,
    actorDefinitionResourceReqs: ScopedResourceRequirements?,
    workerDefaultResourceReqs: ResourceRequirements?,
    jobType: JobTypeResourceLimit.JobType,
  ): ResourceRequirements {
    val jobSpecificActorDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType)
    val jobSpecificActorResourceReqs = getResourceRequirementsForJobType(actorResourceReqs, jobType)

    val defaultActorDefinitionResourceReqs = actorDefinitionResourceReqs?.default

    val mergedResourceRequirements =
      mergeResourceRequirements(
        connectionResourceReqs,
        jobSpecificActorResourceReqs,
        jobSpecificActorDefinitionResourceReqs,
        defaultActorDefinitionResourceReqs,
        workerDefaultResourceReqs,
      )

    logger.info {
      "Merged resource requirements. mergedResourceReqs=$mergedResourceRequirements " +
        "connectionResourceReqs=$connectionResourceReqs " +
        "actorResourceReqs=$actorResourceReqs " +
        "actorDefinitionResourceReqs=$actorDefinitionResourceReqs " +
        "workerDefaultResourceReqs=$workerDefaultResourceReqs " +
        "jobType=$jobType"
    }

    return mergedResourceRequirements
  }

  /**
   * Given a list of resource requirements, merges them together. Earlier reqs override later ones.
   *
   * Example usage can be: 1. Given connection-level and worker-default resource requirements, returns
   * the final resource requirements generated by merging the provided requirements in hierarchy
   * order.
   *
   * Connection-level resource requirements take precedence over worker-default resource
   * requirements.
   *
   * 2. Given Actor Definition level and worker default resource requirements, returns the final
   * resource requirements generated by merging them; with Actor Definition level resource
   * requirements taking higher precedence over worker default resource requirements.
   *
   * @param resourceReqs - list of resource request to merge
   * @return merged resource req
   */
  @JvmStatic
  fun mergeResourceRequirements(vararg resourceReqs: ResourceRequirements?): ResourceRequirements {
    val outputReqs = ResourceRequirements()
    val reversed: MutableList<ResourceRequirements?> = mutableListOf(*resourceReqs)
    reversed.reverse()

    // start from the lowest priority requirements so that we can repeatedly override the output
    // requirements to guarantee that we end with the highest priority setting for each
    for (resourceReq in reversed) {
      if (resourceReq == null) {
        continue
      }
      if (resourceReq.cpuRequest != null) {
        outputReqs.cpuRequest = resourceReq.cpuRequest
      }
      if (resourceReq.cpuLimit != null) {
        outputReqs.cpuLimit = resourceReq.cpuLimit
      }
      if (resourceReq.memoryRequest != null) {
        outputReqs.memoryRequest = resourceReq.memoryRequest
      }
      if (resourceReq.memoryLimit != null) {
        outputReqs.memoryLimit = resourceReq.memoryLimit
      }
      if (resourceReq.ephemeralStorageRequest != null) {
        outputReqs.ephemeralStorageRequest = resourceReq.ephemeralStorageRequest
      }
      if (resourceReq.ephemeralStorageLimit != null) {
        outputReqs.ephemeralStorageLimit = resourceReq.ephemeralStorageLimit
      }
    }
    return outputReqs
  }

  /**
   * Given an actor definition resource requirements and a job type, returns the resource requirements
   * in it.
   */
  @JvmStatic
  fun getResourceRequirementsForJobType(
    actorDefResourceReqs: ScopedResourceRequirements?,
    jobType: JobTypeResourceLimit.JobType,
  ): ResourceRequirements? {
    if (actorDefResourceReqs == null) {
      return null
    }
    val jobTypeResourceRequirement =
      actorDefResourceReqs.jobSpecific
        .stream()
        .filter { jobSpecific: JobTypeResourceLimit -> jobSpecific.jobType == jobType }
        .map { obj: JobTypeResourceLimit -> obj.resourceRequirements }
        .toList()
    require(jobTypeResourceRequirement.size <= 1) { "Should only have one resource requirement per job type." }
    return if (jobTypeResourceRequirement.isEmpty()) null else jobTypeResourceRequirement[0]
  }

  /**
   * Utility for deserializing from a raw json string.
   *
   * @param rawOverrides A json string to be parsed.
   * @return ResourceRequirements parsed from the string.
   */
  @JvmStatic
  fun parse(rawOverrides: String): ResourceRequirements? {
    if (rawOverrides.isEmpty()) {
      return null
    }
    val json = Jsons.deserialize(rawOverrides)
    return Jsons.`object`(json, ResourceRequirements::class.java)
  }
}
