/*
 * Copyright (c) 2020-2025 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config.helpers

import com.google.common.base.Preconditions
import io.airbyte.commons.json.Jsons
import io.airbyte.config.JobTypeResourceLimit
import io.airbyte.config.ResourceRequirements
import io.airbyte.config.ScopedResourceRequirements

/**
 * Manages resource requirements for different types of jobs. We follow a standard pattern of
 * priority for which requirements get used. See getResourceRequirements below.
 *
 * Auto-converted to Kotlin w/ some manual cleanup.
 */
object ResourceRequirementsUtils {
  /**
   * Given connection-level resource requirements, actor-definition-level resource requirements,
   * worker-default resource requirements, and a job type, returns the final resource requirements
   * generated by merging the provided requirements in hierarchy order.
   *
   * Connection-level resource requirements take precedence over actor-definition level resource
   * requirements. Within the actor-definition level requirements, job-type-specific requirements take
   * precedence over default definition requirements. Actor-definition level resource requirements
   * take precedence over worker default resource requirements.
   *
   * @param connectionResourceReqs - the resource requirements set on the connection
   * @param actorDefinitionResourceReqs - the resource requirements set on the actor definition
   * @param workerDefaultResourceReqs - the default worker resource requirements set in the env
   * variables
   * @param jobType - type of job to extract resource requirements for from the actor definition reqs
   * @return resource requirements, if present, otherwise an empty ResourceRequirements object.
   */
  @JvmStatic
  fun getResourceRequirements(
    connectionResourceReqs: ResourceRequirements?,
    actorDefinitionResourceReqs: ScopedResourceRequirements?,
    workerDefaultResourceReqs: ResourceRequirements?,
    jobType: JobTypeResourceLimit.JobType,
  ): ResourceRequirements {
    val jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType)
    val defaultDefinitionResourceReqs = actorDefinitionResourceReqs?.default
    return mergeResourceRequirements(
      connectionResourceReqs,
      jobSpecificDefinitionResourceReqs,
      defaultDefinitionResourceReqs,
      workerDefaultResourceReqs,
    )
  }

  /**
   * Given a list of resource requirements, merges them together. Earlier reqs override later ones.
   *
   * Example usage can be: 1. Given connection-level and worker-default resource requirements, returns
   * the final resource requirements generated by merging the provided requirements in hierarchy
   * order.
   *
   * Connection-level resource requirements take precedence over worker-default resource
   * requirements.
   *
   * 2. Given Actor Definition level and worker default resource requirements, returns the final
   * resource requirements generated by merging them; with Actor Definition level resource
   * requirements taking higher precedence over worker default resource requirements.
   *
   * @param resourceReqs - list of resource request to merge
   * @return merged resource req
   */
  @JvmStatic
  fun mergeResourceRequirements(vararg resourceReqs: ResourceRequirements?): ResourceRequirements {
    val outputReqs = ResourceRequirements()
    val reversed: MutableList<ResourceRequirements?> = mutableListOf(*resourceReqs)
    reversed.reverse()

    // start from the lowest priority requirements so that we can repeatedly override the output
    // requirements to guarantee that we end with the highest priority setting for each
    for (resourceReq in reversed) {
      if (resourceReq == null) {
        continue
      }
      if (resourceReq.cpuRequest != null) {
        outputReqs.cpuRequest = resourceReq.cpuRequest
      }
      if (resourceReq.cpuLimit != null) {
        outputReqs.cpuLimit = resourceReq.cpuLimit
      }
      if (resourceReq.memoryRequest != null) {
        outputReqs.memoryRequest = resourceReq.memoryRequest
      }
      if (resourceReq.memoryLimit != null) {
        outputReqs.memoryLimit = resourceReq.memoryLimit
      }
      if (resourceReq.ephemeralStorageRequest != null) {
        outputReqs.ephemeralStorageRequest = resourceReq.ephemeralStorageRequest
      }
      if (resourceReq.ephemeralStorageLimit != null) {
        outputReqs.ephemeralStorageLimit = resourceReq.ephemeralStorageLimit
      }
    }
    return outputReqs
  }

  /**
   * Given an actor definition resource requirements and a job type, returns the resource requirements
   * in it.
   */
  @JvmStatic
  fun getResourceRequirementsForJobType(
    actorDefResourceReqs: ScopedResourceRequirements?,
    jobType: JobTypeResourceLimit.JobType,
  ): ResourceRequirements? {
    if (actorDefResourceReqs == null) {
      return null
    }
    val jobTypeResourceRequirement =
      actorDefResourceReqs.jobSpecific
        .stream()
        .filter { jobSpecific: JobTypeResourceLimit -> jobSpecific.jobType == jobType }
        .map { obj: JobTypeResourceLimit -> obj.resourceRequirements }
        .toList()
    Preconditions.checkArgument(jobTypeResourceRequirement.size <= 1, "Should only have one resource requirement per job type.")
    return if (jobTypeResourceRequirement.isEmpty()) null else jobTypeResourceRequirement[0]
  }

  /**
   * Utility for deserializing from a raw json string.
   *
   * @param rawOverrides A json string to be parsed.
   * @return ResourceRequirements parsed from the string.
   */
  @JvmStatic
  fun parse(rawOverrides: String): ResourceRequirements? {
    if (rawOverrides.isEmpty()) {
      return null
    }
    val json = Jsons.deserialize(rawOverrides)
    return Jsons.`object`(json, ResourceRequirements::class.java)
  }
}
