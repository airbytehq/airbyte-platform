/*
 * Copyright (c) 2023 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config.helpers;

import com.google.common.base.Preconditions;
import io.airbyte.commons.json.Jsons;
import io.airbyte.config.ActorDefinitionResourceRequirements;
import io.airbyte.config.JobTypeResourceLimit;
import io.airbyte.config.JobTypeResourceLimit.JobType;
import io.airbyte.config.ResourceRequirements;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

/**
 * Manages resource requirements for different types of jobs. We follow a standard pattern of
 * priority for which requirements get used. See getResourceRequirements below.
 */
public class ResourceRequirementsUtils {

  /**
   * Given connection-level resource requirements, actor-definition-level resource requirements,
   * worker-default resource requirements, and a job type, returns the final resource requirements
   * generated by merging the provided requirements in hierarchy order.
   *
   * Connection-level resource requirements take precendence over actor-definition level resource
   * requirements. Within the actor-definition level requirements, job-type-specific requirements take
   * precedence over default definition requirements. Actor-definition level resource requirements
   * take precedence over worker default resource requirements.
   *
   * @param connectionResourceReqs - the resource requirements set on the connection
   * @param actorDefinitionResourceReqs - the resource requirements set on the actor definition
   * @param workerDefaultResourceReqs - the default worker resource requirements set in the env
   *        variables
   * @param jobType - type of job to extract resource requirements for from the actor definition reqs
   * @return resource requirements, if present, otherwise an empty ResourceRequirements object.
   */
  public static ResourceRequirements getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs,
                                                             @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs,
                                                             @Nullable final ResourceRequirements workerDefaultResourceReqs,
                                                             final JobType jobType) {
    final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType)
        .orElse(null);
    final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs)
        .map(ActorDefinitionResourceRequirements::getDefault).orElse(null);
    return mergeResourceRequirements(
        connectionResourceReqs,
        jobSpecificDefinitionResourceReqs,
        defaultDefinitionResourceReqs,
        workerDefaultResourceReqs);
  }

  /**
   * Merge two ResourceRequirements into one.
   *
   * Example usage can be: 1. Given connection-level and worker-default resource requirements, returns
   * the final resource requirements generated by merging the provided requirements in hierarchy
   * order.
   *
   * Connection-level resource requirements take precendence over worker-default resource
   * requirements.
   *
   * 2. Given Actor Definition level and worker default resource requirements, returns the final
   * resource requirements generated by merging them; with Actor Definition level resource
   * requirements taking higher precedence over worker default resource requirements.
   *
   * @param higherPriorityResourceReqs - Will always respect the resources requirements defined in
   *        this parameter.
   * @param lowerPriorityResourceReqs - the default resource requirements. Will use this if it wasn't
   *        defined in higherPriorityResourceReqs.
   * @return resource requirements, if present, otherwise an empty ResourceRequirements object.
   */
  public static ResourceRequirements getResourceRequirements(@Nullable final ResourceRequirements higherPriorityResourceReqs,
                                                             @Nullable final ResourceRequirements lowerPriorityResourceReqs) {
    return mergeResourceRequirements(
        higherPriorityResourceReqs,
        lowerPriorityResourceReqs);
  }

  /**
   * Given a list of resource requirements, merges them together. Earlier reqs override later ones.
   *
   * @param resourceReqs - list of resource request to merge
   * @return merged resource req
   */
  private static ResourceRequirements mergeResourceRequirements(final ResourceRequirements... resourceReqs) {
    final ResourceRequirements outputReqs = new ResourceRequirements();
    final List<ResourceRequirements> reversed = new ArrayList<>(Arrays.asList(resourceReqs));
    Collections.reverse(reversed);

    // start from the lowest priority requirements so that we can repeatedly override the output
    // requirements to guarantee that we end with the highest priority setting for each
    for (final ResourceRequirements resourceReq : reversed) {
      if (resourceReq == null) {
        continue;
      }

      if (resourceReq.getCpuRequest() != null) {
        outputReqs.setCpuRequest(resourceReq.getCpuRequest());
      }
      if (resourceReq.getCpuLimit() != null) {
        outputReqs.setCpuLimit(resourceReq.getCpuLimit());
      }
      if (resourceReq.getMemoryRequest() != null) {
        outputReqs.setMemoryRequest(resourceReq.getMemoryRequest());
      }
      if (resourceReq.getMemoryLimit() != null) {
        outputReqs.setMemoryLimit(resourceReq.getMemoryLimit());
      }
    }
    return outputReqs;
  }

  /**
   * Given an actor definition resource requirements and a job type, returns the resource requirements
   * in it.
   */
  public static Optional<ResourceRequirements> getResourceRequirementsForJobType(final ActorDefinitionResourceRequirements actorDefResourceReqs,
                                                                                 final JobType jobType) {
    if (actorDefResourceReqs == null) {
      return Optional.empty();
    }

    final List<ResourceRequirements> jobTypeResourceRequirement = actorDefResourceReqs.getJobSpecific()
        .stream()
        .filter(jobSpecific -> jobSpecific.getJobType() == jobType).map(JobTypeResourceLimit::getResourceRequirements).collect(
            Collectors.toList());

    Preconditions.checkArgument(jobTypeResourceRequirement.size() <= 1, "Should only have one resource requirement per job type.");
    return jobTypeResourceRequirement.isEmpty()
        ? Optional.empty()
        : Optional.of(jobTypeResourceRequirement.get(0));
  }

  /**
   * Utility for deserializing from a raw json string.
   *
   * @param rawOverrides A json string to be parsed.
   * @return ResourceRequirements parsed from the string.
   */
  public static ResourceRequirements parse(final String rawOverrides) {
    if (rawOverrides.isEmpty()) {
      return null;
    }

    final var json = Jsons.deserialize(rawOverrides);
    return Jsons.object(json, ResourceRequirements.class);
  }

}
