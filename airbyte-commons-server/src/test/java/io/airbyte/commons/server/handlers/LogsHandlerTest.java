/*
 * Copyright (c) 2023 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.commons.server.handlers;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import io.airbyte.api.model.generated.LogType;
import io.airbyte.api.model.generated.LogsRequestBody;
import io.airbyte.commons.constants.AirbyteCatalogConstants;
import io.airbyte.config.Configs;
import io.airbyte.config.Configs.WorkerEnvironment;
import io.airbyte.config.helpers.LogClientSingleton;
import io.airbyte.config.helpers.LogConfigs;
import java.io.File;
import java.nio.charset.Charset;
import java.nio.file.Path;
import org.apache.commons.io.IOUtils;
import org.junit.jupiter.api.Test;

class LogsHandlerTest {

  @Test
  void testServerLogs() {
    final Configs configs = mock(Configs.class);
    when(configs.getWorkspaceRoot()).thenReturn(Path.of("/workspace"));
    when(configs.getWorkerEnvironment()).thenReturn(WorkerEnvironment.DOCKER);
    when(configs.getLogConfigs()).thenReturn(LogConfigs.EMPTY);

    final File expected = Path.of(String.format("/workspace/server/logs/%s", LogClientSingleton.LOG_FILENAME)).toFile();
    final File actual = new LogsHandler(configs).getLogs(new LogsRequestBody().logType(LogType.SERVER));

    assertEquals(expected, actual);
  }

  @Test
  void testSchedulerLogs() {
    final Configs configs = mock(Configs.class);
    when(configs.getWorkspaceRoot()).thenReturn(Path.of("/workspace"));
    when(configs.getWorkerEnvironment()).thenReturn(WorkerEnvironment.DOCKER);
    when(configs.getLogConfigs()).thenReturn(LogConfigs.EMPTY);

    final File expected = Path.of(String.format("/workspace/scheduler/logs/%s", LogClientSingleton.LOG_FILENAME)).toFile();
    final File actual = new LogsHandler(configs).getLogs(new LogsRequestBody().logType(LogType.SCHEDULER));

    assertEquals(expected, actual);
  }

  /**
   * This test ensures the masking file generated by
   * {@link io.airbyte.config.specs.ConnectorSpecMaskGenerator} is accessible in the server. This is
   * required to ensure the server masks connector secrets in logs. Since the logic and the generated
   * spec come from different modules the easiest way to test this is in a downstream consumer
   * application.
   */
  @Test
  void testConnectorSecretMaskingFileIsAccessible() {
    assertDoesNotThrow(
        () -> IOUtils.toString(getClass().getResourceAsStream(AirbyteCatalogConstants.LOCAL_SECRETS_MASKS_PATH), Charset.defaultCharset()));
  }

}
