import org.openapitools.generator.gradle.plugin.tasks.GenerateTask
import java.io.InputStream
import java.io.OutputStream
import java.net.URL

plugins {
  id("io.airbyte.gradle.jvm.lib")
}

dependencies {
  annotationProcessor(libs.micronaut.openapi)

  ksp(libs.micronaut.openapi)
  ksp(platform(libs.micronaut.platform))
  ksp(libs.bundles.micronaut.annotation.processor)
  ksp(libs.v3.swagger.annotations)
  ksp(libs.jackson.kotlin)
  ksp(libs.moshi.kotlin)

  api(project(":oss:airbyte-api:commons"))
  api(project(":oss:airbyte-api:server-api"))
  api(project(":oss:airbyte-commons-micronaut"))

  implementation(platform(libs.micronaut.platform))
  implementation(libs.bundles.micronaut)
  implementation(libs.jakarta.annotation.api)
  implementation(libs.jakarta.ws.rs.api)
  implementation(libs.jakarta.validation.api)
  implementation(libs.jackson.datatype)
  implementation(libs.jackson.databind)
  implementation(libs.openapi.jackson.databind.nullable)
  implementation(libs.reactor.core)
  implementation(libs.slf4j.api)
  implementation(libs.swagger.annotations)
  implementation(project(":oss:airbyte-commons"))

  compileOnly(libs.v3.swagger.annotations)

  testRuntimeOnly(libs.junit.jupiter.engine)
  testImplementation(libs.bundles.junit)
  testImplementation(libs.bundles.jackson)
  testImplementation(libs.assertj.core)
  testImplementation(libs.junit.pioneer)
  testImplementation(libs.mockk)
  testImplementation(libs.kotlin.test.runner.junit5)
}

val openapiSpecFilePath: String = "${layout.buildDirectory.get()}/openapi/manifest-server-openapi.yaml"
val remoteSpecUrl = "https://raw.githubusercontent.com/airbytehq/airbyte-python-cdk/refs/tags/v7.4.1/airbyte_cdk/manifest_server/openapi.yaml"

val downloadManifestServerSpec =
  tasks.register("downloadManifestServerSpec") {
    val specFile = file(openapiSpecFilePath)

    inputs.property("specUrl", remoteSpecUrl)
    outputs.file(specFile)

    doLast {
      specFile.parentFile.mkdirs()
      val url = URL(remoteSpecUrl)
      url.openStream().use { input: InputStream ->
        specFile.outputStream().use { output: OutputStream ->
          input.copyTo(output)
        }
      }
      println("Downloaded OpenAPI spec from $remoteSpecUrl to $specFile")
    }
  }

val genManifestServerApiClient =
  tasks.register<GenerateTask>("genManifestServerApiClient") {
    val clientOutputDir = "${getLayout().buildDirectory.get()}/generated/manifestserverapi/client"

    inputs.files(downloadManifestServerSpec.get().outputs).withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.dir(clientOutputDir)

    generatorName = "kotlin"
    inputSpec = openapiSpecFilePath
    outputDir = clientOutputDir

    apiPackage = "io.airbyte.manifestserver.api.client.generated"
    invokerPackage = "io.airbyte.manifestserver.api.client.invoker.generated"
    modelPackage = "io.airbyte.manifestserver.api.client.model.generated"

    typeMappings =
      mapOf(
        "SliceDescriptor" to "kotlin.Any",
      )

    schemaMappings =
      mapOf(
        "ConnectorConfig" to "com.fasterxml.jackson.databind.JsonNode",
        "Manifest" to "com.fasterxml.jackson.databind.JsonNode",
      )

    generateApiDocumentation = false

    configOptions =
      mapOf(
        "enumPropertyNaming" to "UPPERCASE",
        "generatePom" to "false",
        "interfaceOnly" to "true",
        "serializationLibrary" to "jackson",
      )

    doLast {
      // Delete file generated by the client task
      delete(file("${outputDir.get()}/src/main/kotlin/org"))

      val generatedDomainClientsPath = "${outputDir.get()}/src/main/kotlin/io/airbyte/manifestserver/api/client/generated"
      updateDomainClientsWithFailsafe(generatedDomainClientsPath)
      // the kotlin client (as opposed to the java client) doesn't include the response body in the exception message.
      updateDomainClientsToIncludeHttpResponseBodyOnClientException(generatedDomainClientsPath)
    }

    dependsOn(":oss:airbyte-api:server-api:genApiClient")
  }

sourceSets {
  main {
    kotlin {
      srcDirs(
        "${project.layout.buildDirectory.get()}/generated/manifestserverapi/client/src/main/kotlin",
        "$projectDir/src/main/kotlin",
      )
    }
    resources {
      srcDir("$projectDir/src/main/openapi/")
    }
  }
}

tasks.withType<JavaCompile>().configureEach {
  options.compilerArgs = listOf("-parameters")
}

tasks.named("compileKotlin") {
  dependsOn(genManifestServerApiClient)
}

// uses afterEvaluate because at configuration time, the kspKotlin task does not exist.
afterEvaluate {
  tasks.named("kspKotlin").configure {
    mustRunAfter(genManifestServerApiClient)
  }
}

private fun updateDomainClientsWithFailsafe(clientPath: String) {
  /*
   * UPDATE domain clients to use Failsafe.
   */
  val dir = file(clientPath)
  dir.walk().forEach { domainClient ->
    if (domainClient.name.endsWith(".kt")) {
      var domainClientFileText = domainClient.readText()

      // replace class declaration
      domainClientFileText =
        domainClientFileText.replace(
          "class (\\S+)\\(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient\\) : ApiClient\\(basePath, client\\)"
            .toRegex(),
          "class $1(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient, policy : RetryPolicy<okhttp3.Response> = RetryPolicy.ofDefaults()) : ApiClient(basePath, client, policy)",
        )

      // add imports if not exist
      if (!domainClientFileText.contains("import dev.failsafe.RetryPolicy")) {
        val newImports = "import dev.failsafe.RetryPolicy"
        domainClientFileText = domainClientFileText.replaceFirst("import ", "$newImports\nimport ")
      }

      domainClient.writeText(domainClientFileText)
    }
  }

  // Update ApiClient to support RetryPolicy
  val apiClientPath =
    "${project.layout.buildDirectory.get()}/generated/manifestserverapi/client/" +
      "src/main/kotlin/org/openapitools/client/infrastructure/ApiClient.kt"
  val apiClientFile = file(apiClientPath)
  if (apiClientFile.exists()) {
    var apiClientText = apiClientFile.readText()

    // Add RetryPolicy import
    if (!apiClientText.contains("import dev.failsafe.RetryPolicy")) {
      apiClientText =
        apiClientText.replace(
          "import com.fasterxml.jackson.core.type.TypeReference",
          "import com.fasterxml.jackson.core.type.TypeReference\nimport dev.failsafe.RetryPolicy",
        )
    }

    // Update constructor to include RetryPolicy parameter
    apiClientText =
      apiClientText.replace(
        "open class ApiClient(val baseUrl: String, val client: Call.Factory = defaultClient)",
        "open class ApiClient(val baseUrl: String, val client: Call.Factory = defaultClient, val policy: RetryPolicy<okhttp3.Response> = RetryPolicy.ofDefaults())",
      )

    apiClientFile.writeText(apiClientText)
  }
}

private fun updateDomainClientsToIncludeHttpResponseBodyOnClientException(clientPath: String) {
  val dir = file(clientPath)
  dir.walk().forEach { domainClient ->
    if (domainClient.name.endsWith(".kt")) {
      val domainClientFileText =
        domainClient.readText().replace(
          "throw ClientException(\"Client error : \${localVarError.statusCode} \${localVarError.message.orEmpty()}\", localVarError.statusCode, localVarResponse)",
          "throw ClientException(\"Client error : \${localVarError.statusCode} \${localVarError.message.orEmpty()} \${localVarError.body ?: \"\"}\", localVarError.statusCode, localVarResponse)",
        )

      domainClient.writeText(domainClientFileText)
    }
  }
}
